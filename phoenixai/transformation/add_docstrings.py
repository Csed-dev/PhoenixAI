"""This module provides functions to automatically generate and insert docstrings into Python code using an LLM."""

import ast

import astor

from base_prompt_handling import (call_llm, read_file,
                                  save_code_to_file, trim_code)


def _generate_docstring_prompt(code_snippet):
    """Generates a prompt for the LLM to create docstrings for a given Python code snippet.

    Args:
        code_snippet (str): The Python code snippet for which to generate docstrings.

    Returns:
        str: The formatted prompt for the LLM."""
    return f"""
You are tasked with creating **only docstrings** for the provided Python code.
Do not execute or modify the code itself. Do not explain anything or provide additional commentary.

**Your task:**

1. **Create or update the module-level docstring** if it is missing or incomplete.
   - The module-level docstring must summarize the purpose of the file and provide any necessary contextual information.
   - It must always appear as the first statement in the file.

2. For each function, method, or class in the file, generate or improve their docstrings, ensuring they follow the **Google-style format** as outlined below.

---

### Google Docstring Guidelines:

#### **Module Docstrings**
- The module docstring summarizes the purpose of the file, including its contents and usage.
- This docstring must be at the top of the file, above any imports or code.

#### **Function & Method Docstrings**
- Describe the usage and behavior (not implementation details).
- Use the following structure:
  - **Args:** List parameters with descriptions and types (if not annotated).
  - **Returns:** Describe the return value and type. For multiple values, list as elements of a returned tuple.
  - **Yields:** For generators, describe the yielded values.
  - **Raises:** List exceptions and their conditions.

#### **Class Docstrings**
- Begin with a single-line summary of the class's purpose.
- Add extended details after a blank line.
- **Attributes:** Document public attributes in the format used for function args.

#### **Inline Comments**
- Use sparingly to clarify non-obvious logic.
- Explain intent or reasoning, not literal code behavior.
- Begin inline comments with `#`, two spaces after the code.

#### Example:
```python
""\"
This module provides utility functions for data processing.

The functions include:
- A function for reading data.
- A function for cleaning data.
- A function for visualizing data.
""\"

def example_function(param1: str, param2: int) -> bool:
    ""\"
    Brief summary of the function.

    Args:
        param1 (str): Description of param1.
        param2 (int): Description of param2.

    Returns:
        bool: Description of the return value.

    Raises:
        ValueError: If a certain error condition occurs.
    ""\"
    pass

### Output Requirements:

1. Do **not** modify the code itself—focus only on creating or improving docstrings.
2. Insert the module-level docstring at the top of the file, followed by any existing imports or code.
3. Ensure all docstrings adhere to the Google-style format.
4. Respond **only** with the updated code and its docstrings, so that I can copy your entire output without any adaptations.

Here is the Python code:
{code_snippet}
"""


def _update_module_docstring(original_ast, llm_ast):
    """Updates the module docstring in the AST, if present, or adds one if none exists.

    Args:
        original_ast (ast.Module): The original AST of the code.
        llm_ast (ast.Module): The AST of the code generated by the LLM."""
    llm_module_docstring = None
    if (
        isinstance(llm_ast.body[0], ast.Expr)
        and isinstance(llm_ast.body[0].value, ast.Constant)
        and isinstance(llm_ast.body[0].value.value, str)
    ):
        llm_module_docstring = llm_ast.body[0].value.value
    if llm_module_docstring:
        if (
            isinstance(original_ast.body[0], ast.Expr)
            and isinstance(original_ast.body[0].value, ast.Constant)
            and isinstance(original_ast.body[0].value.value, str)
        ):
            original_ast.body[0] = ast.Expr(
                value=ast.Constant(value=llm_module_docstring)
            )
        else:
            original_ast.body.insert(
                0, ast.Expr(value=ast.Constant(value=llm_module_docstring))
            )


def _update_function_and_class_docstrings(original_ast, llm_ast):
    """Updates the docstrings of functions and classes in the AST."""
    for node in original_ast.body:
        if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
            for llm_node in llm_ast.body:
                if (
                    isinstance(llm_node, (ast.FunctionDef, ast.ClassDef))
                    and node.name == llm_node.name
                ):
                    if new_docstring := ast.get_docstring(llm_node):
                        node.body = [
                            ast.Expr(value=ast.Constant(value=new_docstring))
                        ] + [
                            n
                            for n in node.body
                            if not isinstance(n, ast.Expr)
                            or not isinstance(n.value, ast.Constant)
                            or not isinstance(n.value.value, str)
                        ]


def _insert_docstrings_to_code(original_code, llm_response):
    """Inserts the generated docstrings into the original code or replaces existing docstrings.

    Args:
        original_code (str): The original Python code.
        llm_response (str): The LLM's response containing the generated docstrings.

    Returns:
        str: The updated code with the inserted docstrings.

    Raises:
        RuntimeError: If there's an error during docstring insertion or if the LLM response is invalid.
    """
    try:
        original_ast = ast.parse(original_code)
        try:
            llm_ast = ast.parse(llm_response)
        except SyntaxError as parse_error:
            raise RuntimeError(
                f"[Docstring-Updater] Ungültiger LLM-Code: {llm_response}"
            ) from parse_error
        _update_module_docstring(original_ast, llm_ast)
        _update_function_and_class_docstrings(original_ast, llm_ast)
        return astor.to_source(original_ast)
    except Exception as e:
        raise RuntimeError(
            f"[Docstring-Updater] Fehler beim Einfügen der Docstrings: {e}"
        ) from e


def process_file_for_docstrings(file_path, max_retries=5):
    """Complete process for generating and inserting docstrings with retry logic.

    Args:
        file_path (str): Path to the Python file.
        max_retries (int): Maximum number of retries for LLM calls.

    Raises:
        RuntimeError: If maximum retries are exceeded without successful docstring generation.
    """
    original_code = read_file(file_path)
    prompt = _generate_docstring_prompt(original_code)
    last_llm_response = None
    for attempt in range(1, max_retries + 1):
        try:
            print(f"[Docstring-Updater] Versuch {attempt}: LLM wird aufgerufen...")
            llm_response = call_llm(prompt)
            last_llm_response = llm_response
            trimmed_code = trim_code(llm_response)
            ast.parse(trimmed_code)
            updated_code = _insert_docstrings_to_code(original_code, trimmed_code)
            save_code_to_file(file_path, updated_code)
            break
        except SyntaxError as e:
            print(
                f"[Docstring-Updater] [Fehler] Syntaxfehler im LLM-Code bei Versuch {attempt}: {e}"
            )
            print(
                f"[Docstring-Updater] [Debug] Ungültiger LLM-Code:\n{last_llm_response}"
            )
        except Exception as e:
            print(
                f"[Docstring-Updater] [Fehler] Unerwarteter Fehler bei Versuch {attempt}: {e}"
            )
        if attempt == max_retries:
            with open(
                "[Docstring-Updater]  last_failed_llm_response.txt",
                "w",
                encoding="utf-8",
            ) as f:
                f.write(
                    last_llm_response
                    or "[Docstring-Updater]  Keine gültige Antwort erhalten."
                )
            raise RuntimeError(
                "[Docstring-Updater]  Fehler: Maximale Anzahl an LLM-Aufrufen erreicht, ohne gültige Docstrings zu erhalten."
            )
